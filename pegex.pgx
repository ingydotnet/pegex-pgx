# This is the Pegex grammar for Pegex grammars!

%grammar pegex
%version 0.3.0
%include pegex_atoms


grammar:
  meta_section
  rule_section
  ( doc_ending | ERROR_rule_definition )

meta_section: ( meta_definition | __ | ERROR_meta_definition )*

rule_section: ( rule_definition | __ )*

meta_definition: / PERCENT meta_name BLANK+ meta_value /

rule_definition: rule_start rule_group ending

rule_start: / ( rule_name ) BLANK* COLON _/

rule_group: any_group

any_group: /_ PIPE? _/ all_group ( /_ PIPE _/ all_group )*

all_group: rule_part (_ rule_part)*

rule_part: rule_item{1,2} % /__ ( PERCENT{1,2} ) __/

rule_item:
  | bracketed_group
  | whitespace_token
  | rule_reference
  | quoted_regex
  | regular_expression
  | error_message

rule_reference:
  /
    ( rule_modifier? )      # [=!.-+]
    ( rule_name )
    ( rule_quantifier? )    # [?*+] {2+} {2,3} {2}
    (! BLANK* COLON )       # Avoid parsing 'foo:'
  /                         # as a rule reference.

quoted_regex:
  / TICK ( [^ TICK ]* ) TICK /

regular_expression:
  SLASH
  whitespace_start?
  (
  | whitespace_must
  | whitespace_maybe
  | quoted_regex
  | regex_rule_reference
  | __
  | regex_raw
  )*
  SLASH

whitespace_start: / ( UNDER UNDER | UNDER) /   # ?? (! [ DASH TILDE ]) 

whitespace_must: /__ UNDER UNDER  (= [ SPACE SLASH CR NL ]) /

whitespace_maybe: /_ UNDER (= [ SPACE SLASH CR NL ]) /

whitespace_token:
    / ( (: UNDER UNDER | UNDER ) ) (! UNDER )/

regex_rule_reference:
  /
    __ ( rule_name )
    (! BLANK* COLON )
  /

regex_raw: / ([^ WS SLASH TICK LANGLE ]+) /

bracketed_group:
    / ( group_modifier? ) LPAREN _/
    rule_group
    /_ RPAREN ( rule_quantifier? ) /

error_message:
    / GRAVE ( [^ GRAVE DOS ]* ) GRAVE /

rule_modifier: / [ BANG EQUAL PLUS DASH DOT ] /

group_modifier: / [ DASH DOT ] /

rule_quantifier:
    / (:
        [ STAR PLUS QMARK ]  |
        LCURLY DIGIT+ (: COMMA DIGIT+ | PLUS)? RCURLY
    ) /

meta_name:
    / ( 'grammar' | 'extends' | 'include' | 'version' ) /

meta_value:
    /
        BLANK*
        ( [^ SEMI BREAK ]*? )
        BLANK*
        ending
    /

rule_name:  scoped_identifier

scoped_identifier: simple_identifier % DOT  # Namespace support

simple_identifier: /
  UNDER* (: ALPHA WORD*)?       # '_', '__' are valid rule names (for pegex_atoms)
  (= [^ WORD ])                 # A digit can never precede the first letter, so '__8bit', '8bit', '_____8bit' are all invalid.
/

ending: /
  _?
  (:
    BREAK _ SEMI? _ |
    comment _ SEMI? _ |
    SEMI _ |
    EOS
  )
/

ws: / (: WS | comment ) /

comment: / HASH ANY* (: BREAK | EOS ) /

###
# Pegex common error recognition and reporting:
###

doc_ending: /_ EOS /

illegal_non_modifier_char: / [^
    WORD LPAREN RPAREN LANGLE SLASH TILDE PIPE GRAVE WS
] /

illegal_non_quantifier_char: / [^
    WORD LPAREN RPAREN LANGLE SLASH TILDE PIPE GRAVE WS
    STAR PLUS QMARK BANG EQUAL PLUS DASH DOT COLON SEMI
] /

ERROR_meta_definition:
    /(= PERCENT WORD+ )/
    `Illegal meta rule`

# Much of this is essentially a duplicate of the above rules, except with added
# error checking

ERROR_rule_definition: ERROR_rule_start ERROR_rule_group ( ending | `Rule ending syntax error` )

ERROR_rule_group: ERROR_any_group | ERROR_all_group

ERROR_all_group: ERROR_rule_part+ % _

ERROR_any_group: ERROR_all_group{2+} % /_ PIPE _/

ERROR_rule_part: ERROR_rule_item{1-2} % /__ ( PERCENT{1,2} ) __/

ERROR_rule_start: / ( rule_name ) BLANK* COLON _/ | `Rule header syntax error`

ERROR_rule_item:
    rule_item |
    ERROR_rule_reference |
    ERROR_regular_expression |
    ERROR_bracketed_group |
    ERROR_error_message

# Errors - rule_reference
ERROR_rule_reference:
    /(=
        rule_modifier? rule_name
        illegal_non_quantifier_char
    )/
    `Illegal character in rule quantifier`
|
    !rule_modifier
    /(=
        illegal_non_modifier_char
        rule_name
        rule_quantifier?       # [?*+] {2+} {2,3} {2}
        (! BLANK* COLON )      # Avoid parsing 'foo:'
    )/                         # as a rule reference.
    `Illegal rule modifier (must be [=!.-+]?)`

# Errors - regular_expression
ERROR_regular_expression:
    /(= SLASH ( [^ SLASH ]* ) doc_ending )/
    `Runaway regular expression; no ending slash at EOF`

# Errors - bracketed_group
ERROR_bracketed_group:
    /(! group_modifier) (= illegal_non_modifier_char LPAREN )/
    `Illegal group rule modifier (can only use .)`
|
    / ( group_modifier? ) LPAREN _/
    rule_group
    (
        =doc_ending
        `Runaway rule group; no ending parens at EOF`
    |
        / (= _ RPAREN illegal_non_quantifier_char ) /
        `Illegal character in group rule quantifier`
    )

# Errors - error_message
ERROR_error_message:
    /(= GRAVE [^ GRAVE DOS ]* [ DOS ] [^ GRAVE ]* GRAVE )/
    `Multi_line error messages not allowed!`
|
    /(= GRAVE [^ GRAVE ]* doc_ending )/
    `Runaway error message; no ending grave at EOF`

# Errors - separation
ERROR_separation:
    /(= _ PERCENT{3} )/
    `Leading separator form (BOK) no longer supported`
|
    /(= _ PERCENT{1,2} [^ WS ] )/
    `Illegal characters in separator indicator`

# vim: set lisp:

